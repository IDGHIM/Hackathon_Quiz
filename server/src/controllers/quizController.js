const Quiz = require('../models/Quiz');
const Question = require('../models/Questions');
const filter = require('leo-profanity');

// Initialisation du filtre des mots interdits avec les dictionnaires français et anglais
const englishDict = filter.getDictionary('en');
filter.loadDictionary('fr');
const frenchDict = filter.getDictionary('fr');
filter.add([...englishDict, ...frenchDict]);

// Controller pour récupérer tous les quiz
exports.index = async (req, res) => {
    try {
        const quizzes = await Quiz.find();
        
        // Pour chaque quiz, récupérer ses questions associées
        const quizzesWithQuestions = await Promise.all(
            quizzes.map(async (quiz) => {
                const questions = await Question.find({ quizId: quiz._id.toString() });
                const adaptedQuestions = questions.map(question => ({
                    id: question._id,
                    question: question.question,
                    optionA: question.answers[0] || "",
                    optionB: question.answers[1] || "",
                    optionC: question.answers[2] || "",
                    correctAnswers: question.correctAnswers || [],
                    category: question.category
                }));
                
                return {
                    id: quiz._id,
                    title: quiz.title,
                    description: quiz.description,
                    category: quiz.category,
                    createdBy: quiz.createdBy,
                    createdAt: quiz.createdAt.toISOString().split("T")[0],
                    isAutoGenerated: quiz.isAutoGenerated,
                    questions: adaptedQuestions
                };
            })
        );
        
        res.json(quizzesWithQuestions);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

// Controller pour récupérer un quiz par son ID
exports.show = async (req, res) => {
    try {
        const quizId = req.params.id;
        const quiz = await Quiz.findById(quizId);
        
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz non trouvé' });
        }
        
        // Récupérer les questions associées à ce quiz
        const questions = await Question.find({ quizId: quizId });
        const adaptedQuestions = questions.map(question => ({
            id: question._id,
            question: question.question,
            optionA: question.answers[0] || "",
            optionB: question.answers[1] || "",
            optionC: question.answers[2] || "",
            correctAnswers: question.correctAnswers || [],
            category: question.category
        }));
        
        const quizWithQuestions = {
            id: quiz._id,
            title: quiz.title,
            description: quiz.description,
            category: quiz.category,
            createdBy: quiz.createdBy,
            createdAt: quiz.createdAt.toISOString().split("T")[0],
            isAutoGenerated: quiz.isAutoGenerated,
            questions: adaptedQuestions
        };
        
        res.json(quizWithQuestions);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

// Controller pour créer un nouveau quiz
exports.create = async (req, res) => {
    try {
        const { title, description, category, createdBy, isAutoGenerated } = req.body;
        
        // Validation des champs requis
        if (!title || !category) {
            return res.status(400).json({ error: 'Le titre et la catégorie sont requis.' });
        }
        
        // Vérification des mots interdits
        const isBannedTitle = filter.check(title);
        const isBannedDescription = description && filter.check(description);
        const isBannedCategory = filter.check(category);
        
        if (isBannedTitle || isBannedDescription || isBannedCategory) {
            return res.status(400).json({ error: 'Le titre, la description ou la catégorie contient des mots interdits.' });
        }
        
        const newQuiz = new Quiz({
            title,
            description,
            category,
            createdBy: createdBy || 'Admin',
            isAutoGenerated: isAutoGenerated || false
        });
        
        await newQuiz.save();
        
        // Retourner le quiz avec le format attendu par le frontend
        const formattedQuiz = {
            id: newQuiz._id,
            title: newQuiz.title,
            description: newQuiz.description,
            category: newQuiz.category,
            createdBy: newQuiz.createdBy,
            createdAt: newQuiz.createdAt.toISOString().split("T")[0],
            isAutoGenerated: newQuiz.isAutoGenerated,
            questions: []
        };
        
        res.status(201).json(formattedQuiz);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
};

// Controller pour mettre à jour un quiz
exports.update = async (req, res) => {
    try {
        const { title, description, category, createdBy } = req.body;
        
        // Validation des champs requis
        if (!title || !category) {
            return res.status(400).json({ error: 'Le titre et la catégorie sont requis.' });
        }
        
        // Vérification des mots interdits
        const isBannedTitle = filter.check(title);
        const isBannedDescription = description && filter.check(description);
        const isBannedCategory = filter.check(category);
        
        if (isBannedTitle || isBannedDescription || isBannedCategory) {
            return res.status(400).json({ error: 'Le titre, la description ou la catégorie contient des mots interdits.' });
        }
        
        const quiz = await Quiz.findByIdAndUpdate(
            req.params.id,
            { title, description, category, createdBy },
            { new: true }
        );
        
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz non trouvé' });
        }
        
        // Mettre à jour le nombre de questions
        const questionsCount = await Question.countDocuments({ quizId: quiz._id.toString() });
        quiz.questionsCount = questionsCount;
        await quiz.save();
        
        // Récupérer les questions associées
        const questions = await Question.find({ quizId: quiz._id.toString() });
        const adaptedQuestions = questions.map(question => ({
            id: question._id,
            question: question.question,
            optionA: question.answers[0] || "",
            optionB: question.answers[1] || "",
            optionC: question.answers[2] || "",
            correctAnswers: question.correctAnswers || [],
            category: question.category
        }));
        
        const formattedQuiz = {
            id: quiz._id,
            title: quiz.title,
            description: quiz.description,
            category: quiz.category,
            createdBy: quiz.createdBy,
            createdAt: quiz.createdAt.toISOString().split("T")[0],
            isAutoGenerated: quiz.isAutoGenerated,
            questions: adaptedQuestions
        };
        
        res.json(formattedQuiz);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
};

// Controller pour supprimer un quiz
exports.delete = async (req, res) => {
    try {
        const quizId = req.params.id;
        
        // Supprimer d'abord toutes les questions associées à ce quiz
        await Question.deleteMany({ quizId: quizId });
        
        // Puis supprimer le quiz
        const quiz = await Quiz.findByIdAndDelete(quizId);
        
        if (!quiz) {
            return res.status(404).json({ message: 'Quiz non trouvé' });
        }
        
        res.json({ message: 'Quiz et ses questions supprimés avec succès' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

// Controller pour dupliquer un quiz
exports.duplicate = async (req, res) => {
    try {
        const originalQuizId = req.params.id;
        
        // Récupérer le quiz original
        const originalQuiz = await Quiz.findById(originalQuizId);
        if (!originalQuiz) {
            return res.status(404).json({ message: 'Quiz original non trouvé' });
        }
        
        // Créer le nouveau quiz
        const newQuiz = new Quiz({
            title: `${originalQuiz.title} (Copie)`,
            description: originalQuiz.description,
            category: `${originalQuiz.category} (Copie)`,
            createdBy: originalQuiz.createdBy,
            isAutoGenerated: false
        });
        
        await newQuiz.save();
        
        // Récupérer et dupliquer les questions
        const originalQuestions = await Question.find({ quizId: originalQuizId });
        const duplicatedQuestions = [];
        
        for (const question of originalQuestions) {
            const newQuestion = new Question({
                question: question.question,
                answers: [...question.answers],
                correctAnswers: [...question.correctAnswers],
                category: newQuiz.category,
                quizId: newQuiz._id.toString()
            });
            
            await newQuestion.save();
            
            duplicatedQuestions.push({
                id: newQuestion._id,
                question: newQuestion.question,
                optionA: newQuestion.answers[0] || "",
                optionB: newQuestion.answers[1] || "",
                optionC: newQuestion.answers[2] || "",
                correctAnswers: newQuestion.correctAnswers || [],
                category: newQuestion.category
            });
        }
        
        // Mettre à jour le nombre de questions
        newQuiz.questionsCount = duplicatedQuestions.length;
        await newQuiz.save();
        
        const formattedQuiz = {
            id: newQuiz._id,
            title: newQuiz.title,
            description: newQuiz.description,
            category: newQuiz.category,
            createdBy: newQuiz.createdBy,
            createdAt: newQuiz.createdAt.toISOString().split("T")[0],
            isAutoGenerated: newQuiz.isAutoGenerated,
            questions: duplicatedQuestions
        };
        
        res.status(201).json(formattedQuiz);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};
